# -*- coding: utf-8 -*-
"""Untitled0.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1xpMErmFwnoKFlWPugvbqzFJs0a6dhQsa
"""

import numpy as np
import pandas as pd
import yfinance as yf
from sklearn.preprocessing import MinMaxScaler
from tensorflow.keras.models import Sequential
from tensorflow.keras.layers import LSTM, Dense, Dropout
import random
import tensorflow as tf
from datetime import datetime, timedelta

# ======================
# 1. SETUP & CONFIGURATION
# ======================
random.seed(42)
np.random.seed(42)
tf.keras.utils.set_random_seed(42)

# ======================
# 2. USER INPUT
# ======================
ticker = input("Enter company ticker (e.g., AAPL, TSLA, MSFT): ").upper()
years = float(input("How many years of historical data? (1-5): "))

# ======================
# 3. FETCH LIVE DATA
# ======================
end_date = datetime.now().strftime('%Y-%m-%d')
start_date = (datetime.now() - timedelta(days=years*365)).strftime('%Y-%m-%d')

print(f"\nFetching {ticker} data from {start_date} to {end_date}...")
data = yf.download(ticker, start=start_date, end=end_date)
data = data[['Open', 'High', 'Low', 'Close', 'Volume']]

if len(data) < 60:
    raise ValueError(f"Only {len(data)} days available - need at least 60 trading days")

print(f"\nSuccess! Got {len(data)} trading days of data")
print(data.tail(3))

# ======================
# 4. PREPROCESSING
# ======================
scaler = MinMaxScaler()
scaled_data = scaler.fit_transform(data)

# ======================
# 5. DYNAMIC LOOKBACK
# ======================
lookback = min(90, len(data) - 31)  # 3 months or max available
print(f"\nUsing {lookback} days lookback period")

# ======================
# 6. CREATE TRAINING DATA
# ======================
X, y = [], []
for i in range(lookback, len(scaled_data)):
    X.append(scaled_data[i-lookback:i])
    y.append(scaled_data[i, 3])  # Close price

X, y = np.array(X), np.array(y)

# ======================
# 7. BUILD MODEL
# ======================
model = Sequential([
    LSTM(64, return_sequences=True, input_shape=(X.shape[1], X.shape[2])),
    Dropout(0.2),
    LSTM(64),
    Dropout(0.2),
    Dense(1)
])

model.compile(optimizer='adam', loss='mse')

# ======================
# 8. TRAIN
# ======================
print("\nTraining model...")
history = model.fit(X, y, epochs=30, batch_size=16, verbose=1)

# ======================
# 9. PREDICT
# ======================
last_sequence = scaled_data[-lookback:].reshape(1, lookback, -1)
prediction = model.predict(last_sequence, verbose=0)[0,0]

# Inverse transform
dummy = np.zeros((1, scaled_data.shape[1]))
dummy[0, 3] = prediction
predicted_price = scaler.inverse_transform(dummy)[0, 3]

# ======================
# 10. RESULTS
# ======================
current_price = float(data['Close'].iloc[-1])
change_pct = (predicted_price - current_price)/current_price * 100

print("\n" + "="*40)
print(f"{ticker} Stock Analysis")
print("="*40)
print(f"Current Price: ${current_price:.2f}")
print(f"Predicted Price: ${predicted_price:.2f} ({change_pct:+.2f}%)")

if change_pct > 2:
    print("\nðŸš€ Recommendation: BUY (Expected Growth)")
elif change_pct < -2:
    print("\nâš ï¸ Recommendation: SELL (Expected Decline)")
else:
    print("\nðŸ”„ Recommendation: HOLD (Neutral Outlook)")

print("\nNote: Always consider other market factors")
print("="*40)